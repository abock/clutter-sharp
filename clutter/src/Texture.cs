// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Clutter {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public  class Texture : Clutter.Actor, Clutter.Scriptable {

		[Obsolete]
		protected Texture(GLib.GType gtype) : base(gtype) {}
		public Texture(IntPtr raw) : base(raw) {}

		[DllImport("clutter")]
		static extern IntPtr clutter_texture_new();

		public Texture () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Texture)) {
				CreateNativeObject (new string [0], new GLib.Value[0]);
				return;
			}
			Raw = clutter_texture_new();
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_texture_new_from_actor(IntPtr actor);

		public Texture (Clutter.Actor actor) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Texture)) {
				throw new InvalidOperationException ("Can't override this constructor.");
			}
			Raw = clutter_texture_new_from_actor(actor == null ? IntPtr.Zero : actor.Handle);
		}

		[DllImport("clutter")]
		static extern unsafe IntPtr clutter_texture_new_from_file(IntPtr filename, out IntPtr error);

		public unsafe Texture (string filename) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Texture)) {
				throw new InvalidOperationException ("Can't override this constructor.");
			}
			IntPtr native_filename = GLib.Marshaller.StringToPtrGStrdup (filename);
			IntPtr error = IntPtr.Zero;
			Raw = clutter_texture_new_from_file(native_filename, out error);
			GLib.Marshaller.Free (native_filename);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
		}

		[GLib.Property ("sync-size")]
		public bool SyncSize {
			get {
				GLib.Value val = GetProperty ("sync-size");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("sync-size", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("keep-aspect-ratio")]
		public bool KeepAspectRatio {
			get {
				GLib.Value val = GetProperty ("keep-aspect-ratio");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("keep-aspect-ratio", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("filename")]
		public string Filename {
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("filename", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("tile-waste")]
		public int TileWaste {
			get {
				GLib.Value val = GetProperty ("tile-waste");
				int ret = (int) val;
				val.Dispose ();
				return ret;
			}
		}

		[GLib.Property ("disable-slicing")]
		public bool DisableSlicing {
			get {
				GLib.Value val = GetProperty ("disable-slicing");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern int clutter_texture_get_filter_quality(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_texture_set_filter_quality(IntPtr raw, int filter_quality);

		[GLib.Property ("filter-quality")]
		public Clutter.TextureQuality FilterQuality {
			get  {
				int raw_ret = clutter_texture_get_filter_quality(Handle);
				Clutter.TextureQuality ret = (Clutter.TextureQuality) raw_ret;
				return ret;
			}
			set  {
				clutter_texture_set_filter_quality(Handle, (int) value);
			}
		}

		[GLib.Property ("pixel-format")]
		public int PixelFormat {
			get {
				GLib.Value val = GetProperty ("pixel-format");
				int ret = (int) val;
				val.Dispose ();
				return ret;
			}
		}

		[GLib.Property ("repeat-x")]
		public bool RepeatX {
			get {
				GLib.Value val = GetProperty ("repeat-x");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("repeat-x", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("repeat-y")]
		public bool RepeatY {
			get {
				GLib.Value val = GetProperty ("repeat-y");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("repeat-y", val);
				val.Dispose ();
			}
		}

		[GLib.CDeclCallback]
		delegate void PixbufChangeVMDelegate (IntPtr texture);

		static PixbufChangeVMDelegate PixbufChangeVMCallback;

		static void pixbufchange_cb (IntPtr texture)
		{
			try {
				Texture texture_managed = GLib.Object.GetObject (texture, false) as Texture;
				texture_managed.OnPixbufChange ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePixbufChange (GLib.GType gtype)
		{
			if (PixbufChangeVMCallback == null)
				PixbufChangeVMCallback = new PixbufChangeVMDelegate (pixbufchange_cb);
			OverrideVirtualMethod (gtype, "pixbuf-change", PixbufChangeVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Texture), ConnectionMethod="OverridePixbufChange")]
		protected virtual void OnPixbufChange ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("pixbuf-change")]
		public event System.EventHandler PixbufChange {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "pixbuf-change");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "pixbuf-change");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void SizeChangeSignalDelegate (IntPtr arg0, int arg1, int arg2, IntPtr gch);

		static void SizeChangeSignalCallback (IntPtr arg0, int arg1, int arg2, IntPtr gch)
		{
			Clutter.SizeChangeArgs args = new Clutter.SizeChangeArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[2];
				args.Args[0] = arg1;
				args.Args[1] = arg2;
				Clutter.SizeChangeHandler handler = (Clutter.SizeChangeHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.CDeclCallback]
		delegate void SizeChangeVMDelegate (IntPtr texture, int width, int height);

		static SizeChangeVMDelegate SizeChangeVMCallback;

		static void sizechange_cb (IntPtr texture, int width, int height)
		{
			try {
				Texture texture_managed = GLib.Object.GetObject (texture, false) as Texture;
				texture_managed.OnSizeChange (width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideSizeChange (GLib.GType gtype)
		{
			if (SizeChangeVMCallback == null)
				SizeChangeVMCallback = new SizeChangeVMDelegate (sizechange_cb);
			OverrideVirtualMethod (gtype, "size-change", SizeChangeVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Texture), ConnectionMethod="OverrideSizeChange")]
		protected virtual void OnSizeChange (int width, int height)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (3);
			GLib.Value[] vals = new GLib.Value [3];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (width);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (height);
			inst_and_params.Append (vals [2]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("size-change")]
		public event Clutter.SizeChangeHandler SizeChange {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "size-change", new SizeChangeSignalDelegate(SizeChangeSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "size-change", new SizeChangeSignalDelegate(SizeChangeSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("clutter")]
		static extern unsafe bool clutter_texture_set_area_from_rgb_data(IntPtr raw, out byte data, bool has_alpha, int x, int y, int width, int height, int rowstride, int bpp, int flags, out IntPtr error);

		public unsafe bool SetAreaFromRgbData(out byte data, bool has_alpha, int x, int y, int width, int height, int rowstride, int bpp, Clutter.TextureFlags flags) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = clutter_texture_set_area_from_rgb_data(Handle, out data, has_alpha, x, y, width, height, rowstride, bpp, (int) flags, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("clutter")]
		static extern unsafe bool clutter_texture_set_from_file(IntPtr raw, IntPtr filename, out IntPtr error);

		public unsafe bool SetFromFile(string filename) {
			IntPtr native_filename = GLib.Marshaller.StringToPtrGStrdup (filename);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = clutter_texture_set_from_file(Handle, native_filename, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_filename);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_texture_handle_get_type();

		public static GLib.GType HandleGetType() {
			IntPtr raw_ret = clutter_texture_handle_get_type();
			GLib.GType ret = new GLib.GType(raw_ret);
			return ret;
		}

		[DllImport("clutter")]
		static extern int clutter_texture_get_max_tile_waste(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_texture_set_max_tile_waste(IntPtr raw, int max_tile_waste);

		public int MaxTileWaste { 
			get {
				int raw_ret = clutter_texture_get_max_tile_waste(Handle);
				int ret = raw_ret;
				return ret;
			}
			set {
				clutter_texture_set_max_tile_waste(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_texture_get_base_size(IntPtr raw, out int width, out int height);

		public void GetBaseSize(out int width, out int height) {
			clutter_texture_get_base_size(Handle, out width, out height);
		}

		[DllImport("clutter")]
		static extern unsafe bool clutter_texture_set_from_rgb_data(IntPtr raw, out byte data, bool has_alpha, int width, int height, int rowstride, int bpp, int flags, out IntPtr error);

		public unsafe bool SetFromRgbData(out byte data, bool has_alpha, int width, int height, int rowstride, int bpp, Clutter.TextureFlags flags) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = clutter_texture_set_from_rgb_data(Handle, out data, has_alpha, width, height, rowstride, bpp, (int) flags, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("clutter")]
		static extern int clutter_texture_error_quark();

		public static int ErrorQuark() {
			int raw_ret = clutter_texture_error_quark();
			int ret = raw_ret;
			return ret;
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_texture_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = clutter_texture_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern unsafe bool clutter_texture_set_from_yuv_data(IntPtr raw, out byte data, int width, int height, int flags, out IntPtr error);

		public unsafe bool SetFromYuvData(out byte data, int width, int height, Clutter.TextureFlags flags) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = clutter_texture_set_from_yuv_data(Handle, out data, width, height, (int) flags, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("clutter")]
		static extern void clutter_scriptable_set_custom_property(IntPtr raw, IntPtr script, IntPtr name, IntPtr value);

		public void SetCustomProperty(Clutter.Script script, string name, GLib.Value value) {
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			IntPtr native_value = GLib.Marshaller.StructureToPtrAlloc (value);
			clutter_scriptable_set_custom_property(Handle, script == null ? IntPtr.Zero : script.Handle, native_name, native_value);
			GLib.Marshaller.Free (native_name);
			value = (GLib.Value) Marshal.PtrToStructure (native_value, typeof (GLib.Value));
			Marshal.FreeHGlobal (native_value);
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_scriptable_get_id(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_scriptable_set_id(IntPtr raw, IntPtr id);

		public string Id { 
			get {
				IntPtr raw_ret = clutter_scriptable_get_id(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
			set {
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				clutter_scriptable_set_id(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

#endregion
	}
}
