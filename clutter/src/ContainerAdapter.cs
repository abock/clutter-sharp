// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Clutter {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class ContainerAdapter : GLib.GInterfaceAdapter, Clutter.Container {

		static ContainerIface iface;

		struct ContainerIface {
			public IntPtr gtype;
			public IntPtr itype;

			public IntPtr actor_added;
			public IntPtr actor_removed;
			public IntPtr child_notify;
			public IntPtr add;
			public IntPtr _remove;
			public ForeachDelegate for_each;
			public IntPtr raise;
			public IntPtr lower;
			public SortDepthOrderDelegate sort_depth_order;
			public IntPtr create_child_meta;
			public IntPtr destroy_child_meta;
			public GetChildMetaDelegate get_child_meta;
		}

		static ContainerAdapter ()
		{
			iface.for_each = new ForeachDelegate (ForeachCallback);
			iface.sort_depth_order = new SortDepthOrderDelegate (SortDepthOrderCallback);
			iface.get_child_meta = new GetChildMetaDelegate (GetChildMetaCallback);
		}


		[GLib.CDeclCallback]
		delegate void ForeachDelegate (IntPtr container, ClutterSharp.CallbackNative cb, IntPtr user_data);

		static void ForeachCallback (IntPtr container, ClutterSharp.CallbackNative cb, IntPtr user_data)
		{
			try {
				Clutter.ContainerImplementor __obj = GLib.Object.GetObject (container, false) as Clutter.ContainerImplementor;
				ClutterSharp.CallbackInvoker cb_invoker = new ClutterSharp.CallbackInvoker (cb, user_data);
				__obj.Foreach (cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.CDeclCallback]
		delegate void SortDepthOrderDelegate (IntPtr container);

		static void SortDepthOrderCallback (IntPtr container)
		{
			try {
				Clutter.ContainerImplementor __obj = GLib.Object.GetObject (container, false) as Clutter.ContainerImplementor;
				__obj.SortDepthOrder ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.CDeclCallback]
		delegate IntPtr GetChildMetaDelegate (IntPtr container, IntPtr actor);

		static IntPtr GetChildMetaCallback (IntPtr container, IntPtr actor)
		{
			try {
				Clutter.ContainerImplementor __obj = GLib.Object.GetObject (container, false) as Clutter.ContainerImplementor;
				Clutter.ChildMeta __result = __obj.GetChildMeta (GLib.Object.GetObject(actor) as Clutter.Actor);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}
		static void Initialize (IntPtr ifaceptr, IntPtr data)
		{
			ContainerIface native_iface = (ContainerIface) Marshal.PtrToStructure (ifaceptr, typeof (ContainerIface));
			native_iface.add = iface.add;
			native_iface._remove = iface._remove;
			native_iface.for_each = iface.for_each;
			native_iface.raise = iface.raise;
			native_iface.lower = iface.lower;
			native_iface.sort_depth_order = iface.sort_depth_order;
			native_iface.create_child_meta = iface.create_child_meta;
			native_iface.destroy_child_meta = iface.destroy_child_meta;
			native_iface.get_child_meta = iface.get_child_meta;
			Marshal.StructureToPtr (native_iface, ifaceptr, false);
			GCHandle gch = (GCHandle) data;
			gch.Free ();
		}

		public ContainerAdapter ()
		{
			InitHandler = new GLib.GInterfaceInitHandler (Initialize);
		}

		ContainerImplementor implementor;

		public ContainerAdapter (ContainerImplementor implementor)
		{
			this.implementor = implementor;
		}

		public ContainerAdapter (IntPtr handle)
		{
			this.handle = handle;
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_container_get_type();

		public override GLib.GType GType {
			get {
				return new GLib.GType (clutter_container_get_type ());
			}
		}

		IntPtr handle;
		public override IntPtr Handle {
			get {
				if (handle != IntPtr.Zero)
					return handle;
				return implementor == null ? IntPtr.Zero : implementor.Handle;
			}
		}

		public static Container GetObject (IntPtr handle, bool owned)
		{
			GLib.Object obj = GLib.Object.GetObject (handle, owned);
			if (obj == null)
				return null;
			else if (obj is ContainerImplementor)
				return new ContainerAdapter (obj as ContainerImplementor);
			else if (obj as Container == null)
				return new ContainerAdapter (obj.Handle);
			else
				return obj as Container;
		}

		public ContainerImplementor Implementor {
			get {
				return implementor;
			}
		}

		[GLib.CDeclCallback]
		delegate void ChildNotifySignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr gch);

		static void ChildNotifySignalCallback (IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr gch)
		{
			Clutter.ChildNotifyArgs args = new Clutter.ChildNotifyArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[2];
				args.Args[0] = GLib.Object.GetObject(arg1) as Clutter.Actor;
				args.Args[1] = arg2;
				Clutter.ChildNotifyHandler handler = (Clutter.ChildNotifyHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("child-notify")]
		public event Clutter.ChildNotifyHandler ChildNotify {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "child-notify", new ChildNotifySignalDelegate(ChildNotifySignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "child-notify", new ChildNotifySignalDelegate(ChildNotifySignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void ActorRemovedSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void ActorRemovedSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.ActorRemovedArgs args = new Clutter.ActorRemovedArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = GLib.Object.GetObject(arg1) as Clutter.Actor;
				Clutter.ActorRemovedHandler handler = (Clutter.ActorRemovedHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("actor-removed")]
		public event Clutter.ActorRemovedHandler ActorRemoved {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "actor-removed", new ActorRemovedSignalDelegate(ActorRemovedSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "actor-removed", new ActorRemovedSignalDelegate(ActorRemovedSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void ActorAddedSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void ActorAddedSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.ActorAddedArgs args = new Clutter.ActorAddedArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = GLib.Object.GetObject(arg1) as Clutter.Actor;
				Clutter.ActorAddedHandler handler = (Clutter.ActorAddedHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("actor-added")]
		public event Clutter.ActorAddedHandler ActorAdded {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "actor-added", new ActorAddedSignalDelegate(ActorAddedSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (GLib.Object.GetObject (Handle), "actor-added", new ActorAddedSignalDelegate(ActorAddedSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_container_add_valist(IntPtr raw, IntPtr first_actor, IntPtr var_args);

		public void AddValist(Clutter.Actor first_actor, IntPtr var_args) {
			clutter_container_add_valist(Handle, first_actor == null ? IntPtr.Zero : first_actor.Handle, var_args);
		}

		[DllImport("clutter")]
		static extern void clutter_container_add_actor(IntPtr raw, IntPtr actor);

		public void AddActor(Clutter.Actor actor) {
			clutter_container_add_actor(Handle, actor == null ? IntPtr.Zero : actor.Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_container_sort_depth_order(IntPtr raw);

		public void SortDepthOrder() {
			clutter_container_sort_depth_order(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_container_lower_child(IntPtr raw, IntPtr actor, IntPtr sibling);

		public void LowerChild(Clutter.Actor actor, Clutter.Actor sibling) {
			clutter_container_lower_child(Handle, actor == null ? IntPtr.Zero : actor.Handle, sibling == null ? IntPtr.Zero : sibling.Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_container_child_get_property(IntPtr raw, IntPtr child, IntPtr property, IntPtr value);

		public void ChildGetProperty(Clutter.Actor child, string property, GLib.Value value) {
			IntPtr native_property = GLib.Marshaller.StringToPtrGStrdup (property);
			IntPtr native_value = GLib.Marshaller.StructureToPtrAlloc (value);
			clutter_container_child_get_property(Handle, child == null ? IntPtr.Zero : child.Handle, native_property, native_value);
			GLib.Marshaller.Free (native_property);
			value = (GLib.Value) Marshal.PtrToStructure (native_value, typeof (GLib.Value));
			Marshal.FreeHGlobal (native_value);
		}

		[DllImport("clutter")]
		static extern void clutter_container_raise_child(IntPtr raw, IntPtr actor, IntPtr sibling);

		public void RaiseChild(Clutter.Actor actor, Clutter.Actor sibling) {
			clutter_container_raise_child(Handle, actor == null ? IntPtr.Zero : actor.Handle, sibling == null ? IntPtr.Zero : sibling.Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_container_remove_valist(IntPtr raw, IntPtr first_actor, IntPtr var_args);

		public void RemoveValist(Clutter.Actor first_actor, IntPtr var_args) {
			clutter_container_remove_valist(Handle, first_actor == null ? IntPtr.Zero : first_actor.Handle, var_args);
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_container_find_child_by_name(IntPtr raw, IntPtr child_name);

		public Clutter.Actor FindChildByName(string child_name) {
			IntPtr native_child_name = GLib.Marshaller.StringToPtrGStrdup (child_name);
			IntPtr raw_ret = clutter_container_find_child_by_name(Handle, native_child_name);
			Clutter.Actor ret = GLib.Object.GetObject(raw_ret) as Clutter.Actor;
			GLib.Marshaller.Free (native_child_name);
			return ret;
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_container_get_child_meta(IntPtr raw, IntPtr actor);

		public Clutter.ChildMeta GetChildMeta(Clutter.Actor actor) {
			IntPtr raw_ret = clutter_container_get_child_meta(Handle, actor == null ? IntPtr.Zero : actor.Handle);
			Clutter.ChildMeta ret = GLib.Object.GetObject(raw_ret) as Clutter.ChildMeta;
			return ret;
		}

		[DllImport("clutter")]
		static extern void clutter_container_remove_actor(IntPtr raw, IntPtr actor);

		public void RemoveActor(Clutter.Actor actor) {
			clutter_container_remove_actor(Handle, actor == null ? IntPtr.Zero : actor.Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_container_foreach(IntPtr raw, ClutterSharp.CallbackNative cb, IntPtr user_data);

		public void Foreach(Clutter.Callback cb) {
			ClutterSharp.CallbackWrapper cb_wrapper = new ClutterSharp.CallbackWrapper (cb);
			clutter_container_foreach(Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_container_get_children(IntPtr raw);

		public GLib.List Children { 
			get {
				IntPtr raw_ret = clutter_container_get_children(Handle);
				GLib.List ret = new GLib.List(raw_ret);
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern void clutter_container_child_set_property(IntPtr raw, IntPtr child, IntPtr property, IntPtr value);

		public void ChildSetProperty(Clutter.Actor child, string property, GLib.Value value) {
			IntPtr native_property = GLib.Marshaller.StringToPtrGStrdup (property);
			IntPtr native_value = GLib.Marshaller.StructureToPtrAlloc (value);
			clutter_container_child_set_property(Handle, child == null ? IntPtr.Zero : child.Handle, native_property, native_value);
			GLib.Marshaller.Free (native_property);
			value = (GLib.Value) Marshal.PtrToStructure (native_value, typeof (GLib.Value));
			Marshal.FreeHGlobal (native_value);
		}

#endregion
	}
}
