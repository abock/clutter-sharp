// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Clutter {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public  class Actor : GLib.InitiallyUnowned {

		[Obsolete]
		protected Actor(GLib.GType gtype) : base(gtype) {}
		public Actor(IntPtr raw) : base(raw) {}

		protected Actor() : base(IntPtr.Zero)
		{
			CreateNativeObject (new string [0], new GLib.Value [0]);
		}

		[GLib.Property ("min-width-set")]
		public bool MinWidthSet {
			get {
				GLib.Value val = GetProperty ("min-width-set");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("min-width-set", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("visible")]
		public bool Visible {
			get {
				GLib.Value val = GetProperty ("visible");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("visible", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("min-height-set")]
		public bool MinHeightSet {
			get {
				GLib.Value val = GetProperty ("min-height-set");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("min-height-set", val);
				val.Dispose ();
			}
		}

		[DllImport("clutter")]
		static extern uint clutter_actor_get_height(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_height(IntPtr raw, uint height);

		[GLib.Property ("height")]
		public uint Height {
			get  {
				uint raw_ret = clutter_actor_get_height(Handle);
				uint ret = raw_ret;
				return ret;
			}
			set  {
				clutter_actor_set_height(Handle, value);
			}
		}

		[GLib.Property ("anchor-y")]
		public int AnchorY {
			get {
				GLib.Value val = GetProperty ("anchor-y");
				int ret = (int) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("anchor-y", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("anchor-x")]
		public int AnchorX {
			get {
				GLib.Value val = GetProperty ("anchor-x");
				int ret = (int) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("anchor-x", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("request-mode")]
		public Clutter.RequestMode RequestMode {
			get {
				GLib.Value val = GetProperty ("request-mode");
				Clutter.RequestMode ret = (Clutter.RequestMode) (Enum) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value((Enum) value);
				SetProperty("request-mode", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("has-clip")]
		public bool HasClip {
			get {
				GLib.Value val = GetProperty ("has-clip");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern bool clutter_actor_get_reactive(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_reactive(IntPtr raw, bool reactive);

		[GLib.Property ("reactive")]
		public bool Reactive {
			get  {
				bool raw_ret = clutter_actor_get_reactive(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				clutter_actor_set_reactive(Handle, value);
			}
		}

		[GLib.Property ("allocation")]
		public Clutter.ActorBox Allocation {
			get {
				GLib.Value val = GetProperty ("allocation");
				Clutter.ActorBox ret = (Clutter.ActorBox) val;
				val.Dispose ();
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern int clutter_actor_get_depth(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_depth(IntPtr raw, int depth);

		[GLib.Property ("depth")]
		public int Depth {
			get  {
				int raw_ret = clutter_actor_get_depth(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				clutter_actor_set_depth(Handle, value);
			}
		}

		[GLib.Property ("rotation-angle-x")]
		public double RotationAngleX {
			get {
				GLib.Value val = GetProperty ("rotation-angle-x");
				double ret = (double) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("rotation-angle-x", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("rotation-angle-y")]
		public double RotationAngleY {
			get {
				GLib.Value val = GetProperty ("rotation-angle-y");
				double ret = (double) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("rotation-angle-y", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("rotation-angle-z")]
		public double RotationAngleZ {
			get {
				GLib.Value val = GetProperty ("rotation-angle-z");
				double ret = (double) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("rotation-angle-z", val);
				val.Dispose ();
			}
		}

		[DllImport("clutter")]
		static extern uint clutter_actor_get_width(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_width(IntPtr raw, uint width);

		[GLib.Property ("width")]
		public uint Width {
			get  {
				uint raw_ret = clutter_actor_get_width(Handle);
				uint ret = raw_ret;
				return ret;
			}
			set  {
				clutter_actor_set_width(Handle, value);
			}
		}

		[GLib.Property ("show-on-set-parent")]
		public bool ShowOnSetParent {
			get {
				GLib.Value val = GetProperty ("show-on-set-parent");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("show-on-set-parent", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("scale-x")]
		public double ScaleX {
			get {
				GLib.Value val = GetProperty ("scale-x");
				double ret = (double) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("scale-x", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("scale-y")]
		public double ScaleY {
			get {
				GLib.Value val = GetProperty ("scale-y");
				double ret = (double) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("scale-y", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("natural-height-set")]
		public bool NaturalHeightSet {
			get {
				GLib.Value val = GetProperty ("natural-height-set");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("natural-height-set", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("rotation-center-x")]
		public Clutter.Vertex RotationCenterX {
			get {
				GLib.Value val = GetProperty ("rotation-center-x");
				Clutter.Vertex ret = (Clutter.Vertex) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = (GLib.Value) value;
				SetProperty("rotation-center-x", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("rotation-center-y")]
		public Clutter.Vertex RotationCenterY {
			get {
				GLib.Value val = GetProperty ("rotation-center-y");
				Clutter.Vertex ret = (Clutter.Vertex) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = (GLib.Value) value;
				SetProperty("rotation-center-y", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("rotation-center-z")]
		public Clutter.Vertex RotationCenterZ {
			get {
				GLib.Value val = GetProperty ("rotation-center-z");
				Clutter.Vertex ret = (Clutter.Vertex) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = (GLib.Value) value;
				SetProperty("rotation-center-z", val);
				val.Dispose ();
			}
		}

		[DllImport("clutter")]
		static extern int clutter_actor_get_x(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_x(IntPtr raw, int x);

		[GLib.Property ("x")]
		public int X {
			get  {
				int raw_ret = clutter_actor_get_x(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				clutter_actor_set_x(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_actor_get_name(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_name(IntPtr raw, IntPtr name);

		[GLib.Property ("name")]
		public string Name {
			get  {
				IntPtr raw_ret = clutter_actor_get_name(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
			set  {
				IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
				clutter_actor_set_name(Handle, native_value);
				GLib.Marshaller.Free (native_value);
			}
		}

		[DllImport("clutter")]
		static extern int clutter_actor_get_y(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_y(IntPtr raw, int y);

		[GLib.Property ("y")]
		public int Y {
			get  {
				int raw_ret = clutter_actor_get_y(Handle);
				int ret = raw_ret;
				return ret;
			}
			set  {
				clutter_actor_set_y(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern bool clutter_actor_get_fixed_position_set(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_fixed_position_set(IntPtr raw, bool is_set);

		[GLib.Property ("fixed-position-set")]
		public bool FixedPositionSet {
			get  {
				bool raw_ret = clutter_actor_get_fixed_position_set(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set  {
				clutter_actor_set_fixed_position_set(Handle, value);
			}
		}

		[GLib.Property ("natural-width-set")]
		public bool NaturalWidthSet {
			get {
				GLib.Value val = GetProperty ("natural-width-set");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("natural-width-set", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("clip")]
		public Clutter.Geometry Clip {
			get {
				GLib.Value val = GetProperty ("clip");
				Clutter.Geometry ret = (Clutter.Geometry) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = (GLib.Value) value;
				SetProperty("clip", val);
				val.Dispose ();
			}
		}

		[GLib.CDeclCallback]
		delegate bool ButtonPressEventSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static bool ButtonPressEventSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.ButtonPressEventArgs args = new Clutter.ButtonPressEventArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = Clutter.ButtonEvent.New (arg1);
				Clutter.ButtonPressEventHandler handler = (Clutter.ButtonPressEventHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			try {
				if (args.RetVal == null)
					return false;
				return ((bool)args.RetVal);
			} catch (Exception) {
				Exception ex = new Exception ("args.RetVal or 'out' property unset or set to incorrect type in Clutter.ButtonPressEventHandler callback");
				GLib.ExceptionManager.RaiseUnhandledException (ex, true);
				// NOTREACHED: above call doesn't return.
				throw ex;
			}
		}

		[GLib.CDeclCallback]
		delegate bool ButtonPressEventVMDelegate (IntPtr actor, IntPtr evnt);

		static ButtonPressEventVMDelegate ButtonPressEventVMCallback;

		static bool buttonpressevent_cb (IntPtr actor, IntPtr evnt)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				return actor_managed.OnButtonPressEvent (Clutter.ButtonEvent.New (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideButtonPressEvent (GLib.GType gtype)
		{
			if (ButtonPressEventVMCallback == null)
				ButtonPressEventVMCallback = new ButtonPressEventVMDelegate (buttonpressevent_cb);
			OverrideVirtualMethod (gtype, "button-press-event", ButtonPressEventVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideButtonPressEvent")]
		protected virtual bool OnButtonPressEvent (Clutter.ButtonEvent evnt)
		{
			GLib.Value ret = new GLib.Value (GLib.GType.Boolean);
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (evnt);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("button-press-event")]
		public event Clutter.ButtonPressEventHandler ButtonPressEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "button-press-event", new ButtonPressEventSignalDelegate(ButtonPressEventSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "button-press-event", new ButtonPressEventSignalDelegate(ButtonPressEventSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate bool KeyReleaseEventSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static bool KeyReleaseEventSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.KeyReleaseEventArgs args = new Clutter.KeyReleaseEventArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = Clutter.KeyEvent.New (arg1);
				Clutter.KeyReleaseEventHandler handler = (Clutter.KeyReleaseEventHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			try {
				if (args.RetVal == null)
					return false;
				return ((bool)args.RetVal);
			} catch (Exception) {
				Exception ex = new Exception ("args.RetVal or 'out' property unset or set to incorrect type in Clutter.KeyReleaseEventHandler callback");
				GLib.ExceptionManager.RaiseUnhandledException (ex, true);
				// NOTREACHED: above call doesn't return.
				throw ex;
			}
		}

		[GLib.CDeclCallback]
		delegate bool KeyReleaseEventVMDelegate (IntPtr actor, IntPtr evnt);

		static KeyReleaseEventVMDelegate KeyReleaseEventVMCallback;

		static bool keyreleaseevent_cb (IntPtr actor, IntPtr evnt)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				return actor_managed.OnKeyReleaseEvent (Clutter.KeyEvent.New (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideKeyReleaseEvent (GLib.GType gtype)
		{
			if (KeyReleaseEventVMCallback == null)
				KeyReleaseEventVMCallback = new KeyReleaseEventVMDelegate (keyreleaseevent_cb);
			OverrideVirtualMethod (gtype, "key-release-event", KeyReleaseEventVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideKeyReleaseEvent")]
		protected virtual bool OnKeyReleaseEvent (Clutter.KeyEvent evnt)
		{
			GLib.Value ret = new GLib.Value (GLib.GType.Boolean);
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (evnt);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("key-release-event")]
		public event Clutter.KeyReleaseEventHandler KeyReleaseEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "key-release-event", new KeyReleaseEventSignalDelegate(KeyReleaseEventSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "key-release-event", new KeyReleaseEventSignalDelegate(KeyReleaseEventSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void UnrealizedVMDelegate (IntPtr actor);

		static UnrealizedVMDelegate UnrealizedVMCallback;

		static void unrealized_cb (IntPtr actor)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				actor_managed.OnUnrealized ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideUnrealized (GLib.GType gtype)
		{
			if (UnrealizedVMCallback == null)
				UnrealizedVMCallback = new UnrealizedVMDelegate (unrealized_cb);
			OverrideVirtualMethod (gtype, "unrealize", UnrealizedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideUnrealized")]
		protected virtual void OnUnrealized ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("unrealize")]
		public event System.EventHandler Unrealized {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unrealize");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "unrealize");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate bool EnterEventSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static bool EnterEventSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.EnterEventArgs args = new Clutter.EnterEventArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = Clutter.CrossingEvent.New (arg1);
				Clutter.EnterEventHandler handler = (Clutter.EnterEventHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			try {
				if (args.RetVal == null)
					return false;
				return ((bool)args.RetVal);
			} catch (Exception) {
				Exception ex = new Exception ("args.RetVal or 'out' property unset or set to incorrect type in Clutter.EnterEventHandler callback");
				GLib.ExceptionManager.RaiseUnhandledException (ex, true);
				// NOTREACHED: above call doesn't return.
				throw ex;
			}
		}

		[GLib.CDeclCallback]
		delegate bool EnterEventVMDelegate (IntPtr actor, IntPtr evnt);

		static EnterEventVMDelegate EnterEventVMCallback;

		static bool enterevent_cb (IntPtr actor, IntPtr evnt)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				return actor_managed.OnEnterEvent (Clutter.CrossingEvent.New (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideEnterEvent (GLib.GType gtype)
		{
			if (EnterEventVMCallback == null)
				EnterEventVMCallback = new EnterEventVMDelegate (enterevent_cb);
			OverrideVirtualMethod (gtype, "enter-event", EnterEventVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideEnterEvent")]
		protected virtual bool OnEnterEvent (Clutter.CrossingEvent evnt)
		{
			GLib.Value ret = new GLib.Value (GLib.GType.Boolean);
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (evnt);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("enter-event")]
		public event Clutter.EnterEventHandler EnterEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "enter-event", new EnterEventSignalDelegate(EnterEventSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "enter-event", new EnterEventSignalDelegate(EnterEventSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate bool KeyPressEventSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static bool KeyPressEventSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.KeyPressEventArgs args = new Clutter.KeyPressEventArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = Clutter.KeyEvent.New (arg1);
				Clutter.KeyPressEventHandler handler = (Clutter.KeyPressEventHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			try {
				if (args.RetVal == null)
					return false;
				return ((bool)args.RetVal);
			} catch (Exception) {
				Exception ex = new Exception ("args.RetVal or 'out' property unset or set to incorrect type in Clutter.KeyPressEventHandler callback");
				GLib.ExceptionManager.RaiseUnhandledException (ex, true);
				// NOTREACHED: above call doesn't return.
				throw ex;
			}
		}

		[GLib.CDeclCallback]
		delegate bool KeyPressEventVMDelegate (IntPtr actor, IntPtr evnt);

		static KeyPressEventVMDelegate KeyPressEventVMCallback;

		static bool keypressevent_cb (IntPtr actor, IntPtr evnt)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				return actor_managed.OnKeyPressEvent (Clutter.KeyEvent.New (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideKeyPressEvent (GLib.GType gtype)
		{
			if (KeyPressEventVMCallback == null)
				KeyPressEventVMCallback = new KeyPressEventVMDelegate (keypressevent_cb);
			OverrideVirtualMethod (gtype, "key-press-event", KeyPressEventVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideKeyPressEvent")]
		protected virtual bool OnKeyPressEvent (Clutter.KeyEvent evnt)
		{
			GLib.Value ret = new GLib.Value (GLib.GType.Boolean);
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (evnt);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("key-press-event")]
		public event Clutter.KeyPressEventHandler KeyPressEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "key-press-event", new KeyPressEventSignalDelegate(KeyPressEventSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "key-press-event", new KeyPressEventSignalDelegate(KeyPressEventSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate bool ButtonReleaseEventSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static bool ButtonReleaseEventSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.ButtonReleaseEventArgs args = new Clutter.ButtonReleaseEventArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = Clutter.ButtonEvent.New (arg1);
				Clutter.ButtonReleaseEventHandler handler = (Clutter.ButtonReleaseEventHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			try {
				if (args.RetVal == null)
					return false;
				return ((bool)args.RetVal);
			} catch (Exception) {
				Exception ex = new Exception ("args.RetVal or 'out' property unset or set to incorrect type in Clutter.ButtonReleaseEventHandler callback");
				GLib.ExceptionManager.RaiseUnhandledException (ex, true);
				// NOTREACHED: above call doesn't return.
				throw ex;
			}
		}

		[GLib.CDeclCallback]
		delegate bool ButtonReleaseEventVMDelegate (IntPtr actor, IntPtr evnt);

		static ButtonReleaseEventVMDelegate ButtonReleaseEventVMCallback;

		static bool buttonreleaseevent_cb (IntPtr actor, IntPtr evnt)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				return actor_managed.OnButtonReleaseEvent (Clutter.ButtonEvent.New (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideButtonReleaseEvent (GLib.GType gtype)
		{
			if (ButtonReleaseEventVMCallback == null)
				ButtonReleaseEventVMCallback = new ButtonReleaseEventVMDelegate (buttonreleaseevent_cb);
			OverrideVirtualMethod (gtype, "button-release-event", ButtonReleaseEventVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideButtonReleaseEvent")]
		protected virtual bool OnButtonReleaseEvent (Clutter.ButtonEvent evnt)
		{
			GLib.Value ret = new GLib.Value (GLib.GType.Boolean);
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (evnt);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("button-release-event")]
		public event Clutter.ButtonReleaseEventHandler ButtonReleaseEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "button-release-event", new ButtonReleaseEventSignalDelegate(ButtonReleaseEventSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "button-release-event", new ButtonReleaseEventSignalDelegate(ButtonReleaseEventSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void ParentSetSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void ParentSetSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.ParentSetArgs args = new Clutter.ParentSetArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = GLib.Object.GetObject(arg1) as Clutter.Actor;
				Clutter.ParentSetHandler handler = (Clutter.ParentSetHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.CDeclCallback]
		delegate void ParentSetVMDelegate (IntPtr actor, IntPtr old_parent);

		static ParentSetVMDelegate ParentSetVMCallback;

		static void parentset_cb (IntPtr actor, IntPtr old_parent)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				actor_managed.OnParentSet (GLib.Object.GetObject(old_parent) as Clutter.Actor);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideParentSet (GLib.GType gtype)
		{
			if (ParentSetVMCallback == null)
				ParentSetVMCallback = new ParentSetVMDelegate (parentset_cb);
			OverrideVirtualMethod (gtype, "parent-set", ParentSetVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideParentSet")]
		protected virtual void OnParentSet (Clutter.Actor old_parent)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (old_parent);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("parent-set")]
		public event Clutter.ParentSetHandler ParentSet {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "parent-set", new ParentSetSignalDelegate(ParentSetSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "parent-set", new ParentSetSignalDelegate(ParentSetSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate bool ScrollEventSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static bool ScrollEventSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.ScrollEventArgs args = new Clutter.ScrollEventArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = Clutter.ScrollEvent.New (arg1);
				Clutter.ScrollEventHandler handler = (Clutter.ScrollEventHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			try {
				if (args.RetVal == null)
					return false;
				return ((bool)args.RetVal);
			} catch (Exception) {
				Exception ex = new Exception ("args.RetVal or 'out' property unset or set to incorrect type in Clutter.ScrollEventHandler callback");
				GLib.ExceptionManager.RaiseUnhandledException (ex, true);
				// NOTREACHED: above call doesn't return.
				throw ex;
			}
		}

		[GLib.CDeclCallback]
		delegate bool ScrollEventVMDelegate (IntPtr actor, IntPtr evnt);

		static ScrollEventVMDelegate ScrollEventVMCallback;

		static bool scrollevent_cb (IntPtr actor, IntPtr evnt)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				return actor_managed.OnScrollEvent (Clutter.ScrollEvent.New (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideScrollEvent (GLib.GType gtype)
		{
			if (ScrollEventVMCallback == null)
				ScrollEventVMCallback = new ScrollEventVMDelegate (scrollevent_cb);
			OverrideVirtualMethod (gtype, "scroll-event", ScrollEventVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideScrollEvent")]
		protected virtual bool OnScrollEvent (Clutter.ScrollEvent evnt)
		{
			GLib.Value ret = new GLib.Value (GLib.GType.Boolean);
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (evnt);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("scroll-event")]
		public event Clutter.ScrollEventHandler ScrollEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "scroll-event", new ScrollEventSignalDelegate(ScrollEventSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "scroll-event", new ScrollEventSignalDelegate(ScrollEventSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void DestoryedVMDelegate (IntPtr actor);

		static DestoryedVMDelegate DestoryedVMCallback;

		static void destoryed_cb (IntPtr actor)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				actor_managed.OnDestoryed ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDestoryed (GLib.GType gtype)
		{
			if (DestoryedVMCallback == null)
				DestoryedVMCallback = new DestoryedVMDelegate (destoryed_cb);
			OverrideVirtualMethod (gtype, "destroy", DestoryedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideDestoryed")]
		protected virtual void OnDestoryed ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("destroy")]
		public event System.EventHandler Destoryed {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "destroy");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "destroy");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void PaintedVMDelegate (IntPtr actor);

		static PaintedVMDelegate PaintedVMCallback;

		static void painted_cb (IntPtr actor)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				actor_managed.OnPainted ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePainted (GLib.GType gtype)
		{
			if (PaintedVMCallback == null)
				PaintedVMCallback = new PaintedVMDelegate (painted_cb);
			OverrideVirtualMethod (gtype, "paint", PaintedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverridePainted")]
		protected virtual void OnPainted ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("paint")]
		public event System.EventHandler Painted {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "paint");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "paint");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void ShownVMDelegate (IntPtr actor);

		static ShownVMDelegate ShownVMCallback;

		static void shown_cb (IntPtr actor)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				actor_managed.OnShown ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideShown (GLib.GType gtype)
		{
			if (ShownVMCallback == null)
				ShownVMCallback = new ShownVMDelegate (shown_cb);
			OverrideVirtualMethod (gtype, "show", ShownVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideShown")]
		protected virtual void OnShown ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("show")]
		public event System.EventHandler Shown {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "show");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "show");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate bool LeaveEventSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static bool LeaveEventSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.LeaveEventArgs args = new Clutter.LeaveEventArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = Clutter.CrossingEvent.New (arg1);
				Clutter.LeaveEventHandler handler = (Clutter.LeaveEventHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			try {
				if (args.RetVal == null)
					return false;
				return ((bool)args.RetVal);
			} catch (Exception) {
				Exception ex = new Exception ("args.RetVal or 'out' property unset or set to incorrect type in Clutter.LeaveEventHandler callback");
				GLib.ExceptionManager.RaiseUnhandledException (ex, true);
				// NOTREACHED: above call doesn't return.
				throw ex;
			}
		}

		[GLib.CDeclCallback]
		delegate bool LeaveEventVMDelegate (IntPtr actor, IntPtr evnt);

		static LeaveEventVMDelegate LeaveEventVMCallback;

		static bool leaveevent_cb (IntPtr actor, IntPtr evnt)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				return actor_managed.OnLeaveEvent (Clutter.CrossingEvent.New (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideLeaveEvent (GLib.GType gtype)
		{
			if (LeaveEventVMCallback == null)
				LeaveEventVMCallback = new LeaveEventVMDelegate (leaveevent_cb);
			OverrideVirtualMethod (gtype, "leave-event", LeaveEventVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideLeaveEvent")]
		protected virtual bool OnLeaveEvent (Clutter.CrossingEvent evnt)
		{
			GLib.Value ret = new GLib.Value (GLib.GType.Boolean);
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (evnt);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("leave-event")]
		public event Clutter.LeaveEventHandler LeaveEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "leave-event", new LeaveEventSignalDelegate(LeaveEventSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "leave-event", new LeaveEventSignalDelegate(LeaveEventSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void FocusOutVMDelegate (IntPtr actor);

		static FocusOutVMDelegate FocusOutVMCallback;

		static void focusout_cb (IntPtr actor)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				actor_managed.OnFocusOut ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideFocusOut (GLib.GType gtype)
		{
			if (FocusOutVMCallback == null)
				FocusOutVMCallback = new FocusOutVMDelegate (focusout_cb);
			OverrideVirtualMethod (gtype, "focus-out", FocusOutVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideFocusOut")]
		protected virtual void OnFocusOut ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("focus-out")]
		public event System.EventHandler FocusOut {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus-out");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus-out");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void HiddenVMDelegate (IntPtr actor);

		static HiddenVMDelegate HiddenVMCallback;

		static void hidden_cb (IntPtr actor)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				actor_managed.OnHidden ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideHidden (GLib.GType gtype)
		{
			if (HiddenVMCallback == null)
				HiddenVMCallback = new HiddenVMDelegate (hidden_cb);
			OverrideVirtualMethod (gtype, "hide", HiddenVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideHidden")]
		protected virtual void OnHidden ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("hide")]
		public event System.EventHandler Hidden {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "hide");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "hide");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void RealizedVMDelegate (IntPtr actor);

		static RealizedVMDelegate RealizedVMCallback;

		static void realized_cb (IntPtr actor)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				actor_managed.OnRealized ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRealized (GLib.GType gtype)
		{
			if (RealizedVMCallback == null)
				RealizedVMCallback = new RealizedVMDelegate (realized_cb);
			OverrideVirtualMethod (gtype, "realize", RealizedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideRealized")]
		protected virtual void OnRealized ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("realize")]
		public event System.EventHandler Realized {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "realize");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "realize");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void FocusInVMDelegate (IntPtr actor);

		static FocusInVMDelegate FocusInVMCallback;

		static void focusin_cb (IntPtr actor)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				actor_managed.OnFocusIn ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideFocusIn (GLib.GType gtype)
		{
			if (FocusInVMCallback == null)
				FocusInVMCallback = new FocusInVMDelegate (focusin_cb);
			OverrideVirtualMethod (gtype, "focus-in", FocusInVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideFocusIn")]
		protected virtual void OnFocusIn ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("focus-in")]
		public event System.EventHandler FocusIn {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus-in");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "focus-in");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate bool MotionEventSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static bool MotionEventSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.MotionEventArgs args = new Clutter.MotionEventArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = Clutter.MotionEvent.New (arg1);
				Clutter.MotionEventHandler handler = (Clutter.MotionEventHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}

			try {
				if (args.RetVal == null)
					return false;
				return ((bool)args.RetVal);
			} catch (Exception) {
				Exception ex = new Exception ("args.RetVal or 'out' property unset or set to incorrect type in Clutter.MotionEventHandler callback");
				GLib.ExceptionManager.RaiseUnhandledException (ex, true);
				// NOTREACHED: above call doesn't return.
				throw ex;
			}
		}

		[GLib.CDeclCallback]
		delegate bool MotionEventVMDelegate (IntPtr actor, IntPtr evnt);

		static MotionEventVMDelegate MotionEventVMCallback;

		static bool motionevent_cb (IntPtr actor, IntPtr evnt)
		{
			try {
				Actor actor_managed = GLib.Object.GetObject (actor, false) as Actor;
				return actor_managed.OnMotionEvent (Clutter.MotionEvent.New (evnt));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call doesn't return
				throw e;
			}
		}

		private static void OverrideMotionEvent (GLib.GType gtype)
		{
			if (MotionEventVMCallback == null)
				MotionEventVMCallback = new MotionEventVMDelegate (motionevent_cb);
			OverrideVirtualMethod (gtype, "motion-event", MotionEventVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Actor), ConnectionMethod="OverrideMotionEvent")]
		protected virtual bool OnMotionEvent (Clutter.MotionEvent evnt)
		{
			GLib.Value ret = new GLib.Value (GLib.GType.Boolean);
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (evnt);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
			bool result = (bool) ret;
			ret.Dispose ();
			return result;
		}

		[GLib.Signal("motion-event")]
		public event Clutter.MotionEventHandler MotionEvent {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "motion-event", new MotionEventSignalDelegate(MotionEventSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "motion-event", new MotionEventSignalDelegate(MotionEventSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_queue_relayout(IntPtr raw);

		public void QueueRelayout() {
			clutter_actor_queue_relayout(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_move_byu(IntPtr raw, int dx, int dy);

		public void MoveByu(int dx, int dy) {
			clutter_actor_move_byu(Handle, dx, dy);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_remove_clip(IntPtr raw);

		public void RemoveClip() {
			clutter_actor_remove_clip(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_positionu(IntPtr raw, out int x, out int y);

		public void GetPositionu(out int x, out int y) {
			clutter_actor_get_positionu(Handle, out x, out y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_unparent(IntPtr raw);

		public void Unparent() {
			clutter_actor_unparent(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_scale(IntPtr raw, double scale_x, double scale_y);

		public void SetScale(double scale_x, double scale_y) {
			clutter_actor_set_scale(Handle, scale_x, scale_y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_move_anchor_point(IntPtr raw, int anchor_x, int anchor_y);

		public void MoveAnchorPoint(int anchor_x, int anchor_y) {
			clutter_actor_move_anchor_point(Handle, anchor_x, anchor_y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_hide_all(IntPtr raw);

		public void HideAll() {
			clutter_actor_hide_all(Handle);
		}

		[DllImport("clutter")]
		static extern int clutter_actor_get_xu(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_xu(IntPtr raw, int x);

		public int Xu { 
			get {
				int raw_ret = clutter_actor_get_xu(Handle);
				int ret = raw_ret;
				return ret;
			}
			set {
				clutter_actor_set_xu(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_transformed_position(IntPtr raw, out int x, out int y);

		public void GetTransformedPosition(out int x, out int y) {
			clutter_actor_get_transformed_position(Handle, out x, out y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_position(IntPtr raw, int x, int y);

		public void SetPosition(int x, int y) {
			clutter_actor_set_position(Handle, x, y);
		}

		[DllImport("clutter")]
		static extern int clutter_actor_get_widthu(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_widthu(IntPtr raw, int width);

		public int Widthu { 
			get {
				int raw_ret = clutter_actor_get_widthu(Handle);
				int ret = raw_ret;
				return ret;
			}
			set {
				clutter_actor_set_widthu(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern int clutter_actor_get_rotationx(IntPtr raw, int axis, out int x, out int y, out int z);

		public int GetRotationx(Clutter.RotateAxis axis, out int x, out int y, out int z) {
			int raw_ret = clutter_actor_get_rotationx(Handle, (int) axis, out x, out y, out z);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("clutter")]
		static extern void clutter_actor_unrealize(IntPtr raw);

		public void Unrealize() {
			clutter_actor_unrealize(Handle);
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_actor_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = clutter_actor_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_realize(IntPtr raw);

		public void Realize() {
			clutter_actor_realize(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_rotationx(IntPtr raw, int axis, int angle, int x, int y, int z);

		public void SetRotationx(Clutter.RotateAxis axis, int angle, int x, int y, int z) {
			clutter_actor_set_rotationx(Handle, (int) axis, angle, x, y, z);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_shader_param(IntPtr raw, IntPtr param, float value);

		public void SetShaderParam(string param, float value) {
			IntPtr native_param = GLib.Marshaller.StringToPtrGStrdup (param);
			clutter_actor_set_shader_param(Handle, native_param, value);
			GLib.Marshaller.Free (native_param);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_apply_relative_transform_to_point(IntPtr raw, IntPtr ancestor, IntPtr point, IntPtr vertex);

		public void ApplyRelativeTransformToPoint(Clutter.Actor ancestor, Clutter.Vertex point, Clutter.Vertex vertex) {
			IntPtr native_point = GLib.Marshaller.StructureToPtrAlloc (point);
			IntPtr native_vertex = GLib.Marshaller.StructureToPtrAlloc (vertex);
			clutter_actor_apply_relative_transform_to_point(Handle, ancestor == null ? IntPtr.Zero : ancestor.Handle, native_point, native_vertex);
			point = Clutter.Vertex.New (native_point);
			Marshal.FreeHGlobal (native_point);
			vertex = Clutter.Vertex.New (native_vertex);
			Marshal.FreeHGlobal (native_vertex);
		}

		[DllImport("clutter")]
		static extern bool clutter_actor_is_rotated(IntPtr raw);

		public bool IsRotated { 
			get {
				bool raw_ret = clutter_actor_is_rotated(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern int clutter_actor_get_yu(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_yu(IntPtr raw, int y);

		public int Yu { 
			get {
				int raw_ret = clutter_actor_get_yu(Handle);
				int ret = raw_ret;
				return ret;
			}
			set {
				clutter_actor_set_yu(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_paint(IntPtr raw);

		public void Paint() {
			clutter_actor_paint(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_anchor_pointu(IntPtr raw, int anchor_x, int anchor_y);

		public void SetAnchorPointu(int anchor_x, int anchor_y) {
			clutter_actor_set_anchor_pointu(Handle, anchor_x, anchor_y);
		}

		[DllImport("clutter")]
		static extern byte clutter_actor_get_paint_opacity(IntPtr raw);

		public byte PaintOpacity { 
			get {
				byte raw_ret = clutter_actor_get_paint_opacity(Handle);
				byte ret = raw_ret;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern int clutter_actor_get_heightu(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_heightu(IntPtr raw, int height);

		public int Heightu { 
			get {
				int raw_ret = clutter_actor_get_heightu(Handle);
				int ret = raw_ret;
				return ret;
			}
			set {
				clutter_actor_set_heightu(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_allocation_box(IntPtr raw, IntPtr box);

		public void GetAllocationBox(Clutter.ActorBox box) {
			IntPtr native_box = GLib.Marshaller.StructureToPtrAlloc (box);
			clutter_actor_get_allocation_box(Handle, native_box);
			box = Clutter.ActorBox.New (native_box);
			Marshal.FreeHGlobal (native_box);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_geometry(IntPtr raw, IntPtr geometry);

		public void GetGeometry(Clutter.Geometry geometry) {
			IntPtr native_geometry = GLib.Marshaller.StructureToPtrAlloc (geometry);
			clutter_actor_get_geometry(Handle, native_geometry);
			geometry = Clutter.Geometry.New (native_geometry);
			Marshal.FreeHGlobal (native_geometry);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_transformed_size(IntPtr raw, out uint width, out uint height);

		public void GetTransformedSize(out uint width, out uint height) {
			clutter_actor_get_transformed_size(Handle, out width, out height);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_geometry(IntPtr raw, IntPtr geometry);

		public void SetGeometry(Clutter.Geometry geometry) {
			IntPtr native_geometry = GLib.Marshaller.StructureToPtrAlloc (geometry);
			clutter_actor_set_geometry(Handle, native_geometry);
			geometry = Clutter.Geometry.New (native_geometry);
			Marshal.FreeHGlobal (native_geometry);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_clipu(IntPtr raw, out int xoff, out int yoff, out int width, out int height);

		public void GetClipu(out int xoff, out int yoff, out int width, out int height) {
			clutter_actor_get_clipu(Handle, out xoff, out yoff, out width, out height);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_hide(IntPtr raw);

		public void Hide() {
			clutter_actor_hide(Handle);
		}

		[DllImport("clutter")]
		static extern bool clutter_actor_should_pick_paint(IntPtr raw);

		public bool ShouldPickPaint() {
			bool raw_ret = clutter_actor_should_pick_paint(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_clip(IntPtr raw, int xoff, int yoff, int width, int height);

		public void SetClip(int xoff, int yoff, int width, int height) {
			clutter_actor_set_clip(Handle, xoff, yoff, width, height);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_scalex(IntPtr raw, out int scale_x, out int scale_y);

		public void GetScalex(out int scale_x, out int scale_y) {
			clutter_actor_get_scalex(Handle, out scale_x, out scale_y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_sizeu(IntPtr raw, int width, int height);

		public void SetSizeu(int width, int height) {
			clutter_actor_set_sizeu(Handle, width, height);
		}

		[DllImport("clutter")]
		static extern double clutter_actor_get_rotation(IntPtr raw, int axis, out int x, out int y, out int z);

		public double GetRotation(Clutter.RotateAxis axis, out int x, out int y, out int z) {
			double raw_ret = clutter_actor_get_rotation(Handle, (int) axis, out x, out y, out z);
			double ret = raw_ret;
			return ret;
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_size(IntPtr raw, out uint width, out uint height);

		public void GetSize(out uint width, out uint height) {
			clutter_actor_get_size(Handle, out width, out height);
		}

		[DllImport("clutter")]
		static extern bool clutter_actor_transform_stage_point(IntPtr raw, int x, int y, out int x_out, out int y_out);

		public bool TransformStagePoint(int x, int y, out int x_out, out int y_out) {
			bool raw_ret = clutter_actor_transform_stage_point(Handle, x, y, out x_out, out y_out);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("clutter")]
		static extern bool clutter_actor_set_shader(IntPtr raw, IntPtr shader);

		public bool SetShader(Clutter.Shader shader) {
			bool raw_ret = clutter_actor_set_shader(Handle, shader == null ? IntPtr.Zero : shader.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_anchor_point(IntPtr raw, int anchor_x, int anchor_y);

		public void SetAnchorPoint(int anchor_x, int anchor_y) {
			clutter_actor_set_anchor_point(Handle, anchor_x, anchor_y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_anchor_point_from_gravity(IntPtr raw, int gravity);

		public Clutter.Gravity AnchorPointFromGravity { 
			set {
				clutter_actor_set_anchor_point_from_gravity(Handle, (int) value);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_move_by(IntPtr raw, int dx, int dy);

		public void MoveBy(int dx, int dy) {
			clutter_actor_move_by(Handle, dx, dy);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_move_anchor_point_from_gravity(IntPtr raw, int gravity);

		public void MoveAnchorPointFromGravity(Clutter.Gravity gravity) {
			clutter_actor_move_anchor_point_from_gravity(Handle, (int) gravity);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_raise(IntPtr raw, IntPtr below);

		public void Raise(Clutter.Actor below) {
			clutter_actor_raise(Handle, below == null ? IntPtr.Zero : below.Handle);
		}

		[DllImport("clutter")]
		static extern double clutter_actor_get_rotationu(IntPtr raw, int axis, out int x, out int y, out int z);

		public double GetRotationu(Clutter.RotateAxis axis, out int x, out int y, out int z) {
			double raw_ret = clutter_actor_get_rotationu(Handle, (int) axis, out x, out y, out z);
			double ret = raw_ret;
			return ret;
		}

		[DllImport("clutter")]
		static extern void clutter_actor_allocate(IntPtr raw, IntPtr box, bool absolute_origin_changed);

		public void Allocate(Clutter.ActorBox box, bool absolute_origin_changed) {
			IntPtr native_box = GLib.Marshaller.StructureToPtrAlloc (box);
			clutter_actor_allocate(Handle, native_box, absolute_origin_changed);
			box = Clutter.ActorBox.New (native_box);
			Marshal.FreeHGlobal (native_box);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_clipu(IntPtr raw, int xoff, int yoff, int width, int height);

		public void SetClipu(int xoff, int yoff, int width, int height) {
			clutter_actor_set_clipu(Handle, xoff, yoff, width, height);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_preferred_size(IntPtr raw, out int min_width_p, out int min_height_p, out int natural_width_p, out int natural_height_p);

		public void GetPreferredSize(out int min_width_p, out int min_height_p, out int natural_width_p, out int natural_height_p) {
			clutter_actor_get_preferred_size(Handle, out min_width_p, out min_height_p, out natural_width_p, out natural_height_p);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_rotationu(IntPtr raw, int axis, double angle, int x, int y, int z);

		public void SetRotationu(Clutter.RotateAxis axis, double angle, int x, int y, int z) {
			clutter_actor_set_rotationu(Handle, (int) axis, angle, x, y, z);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_size(IntPtr raw, int width, int height);

		public void SetSize(int width, int height) {
			clutter_actor_set_size(Handle, width, height);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_show(IntPtr raw);

		public void Show() {
			clutter_actor_show(Handle);
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_actor_get_shader(IntPtr raw);

		public Clutter.Shader Shader { 
			get {
				IntPtr raw_ret = clutter_actor_get_shader(Handle);
				Clutter.Shader ret = GLib.Object.GetObject(raw_ret) as Clutter.Shader;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_actor_get_parent(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_parent(IntPtr raw, IntPtr parent);

		public Clutter.Actor Parent { 
			get {
				IntPtr raw_ret = clutter_actor_get_parent(Handle);
				Clutter.Actor ret = GLib.Object.GetObject(raw_ret) as Clutter.Actor;
				return ret;
			}
			set {
				clutter_actor_set_parent(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_preferred_height(IntPtr raw, int for_width, out int min_height_p, out int natural_height_p);

		public void GetPreferredHeight(int for_width, out int min_height_p, out int natural_height_p) {
			clutter_actor_get_preferred_height(Handle, for_width, out min_height_p, out natural_height_p);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_preferred_width(IntPtr raw, int for_height, out int min_width_p, out int natural_width_p);

		public void GetPreferredWidth(int for_height, out int min_width_p, out int natural_width_p) {
			clutter_actor_get_preferred_width(Handle, for_height, out min_width_p, out natural_width_p);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_transformed_sizeu(IntPtr raw, out int width, out int height);

		public void GetTransformedSizeu(out int width, out int height) {
			clutter_actor_get_transformed_sizeu(Handle, out width, out height);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_positionu(IntPtr raw, int x, int y);

		public void SetPositionu(int x, int y) {
			clutter_actor_set_positionu(Handle, x, y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_allocate_preferred_size(IntPtr raw, bool absolute_origin_changed);

		public void AllocatePreferredSize(bool absolute_origin_changed) {
			clutter_actor_allocate_preferred_size(Handle, absolute_origin_changed);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_move_anchor_pointu(IntPtr raw, int anchor_x, int anchor_y);

		public void MoveAnchorPointu(int anchor_x, int anchor_y) {
			clutter_actor_move_anchor_pointu(Handle, anchor_x, anchor_y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_allocation_geometry(IntPtr raw, IntPtr geom);

		public void GetAllocationGeometry(Clutter.Geometry geom) {
			IntPtr native_geom = GLib.Marshaller.StructureToPtrAlloc (geom);
			clutter_actor_get_allocation_geometry(Handle, native_geom);
			geom = Clutter.Geometry.New (native_geom);
			Marshal.FreeHGlobal (native_geom);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_anchor_point(IntPtr raw, out int anchor_x, out int anchor_y);

		public void GetAnchorPoint(out int anchor_x, out int anchor_y) {
			clutter_actor_get_anchor_point(Handle, out anchor_x, out anchor_y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_abs_allocation_vertices(IntPtr raw, Clutter.Vertex[] verts);

		public void GetAbsAllocationVertices(Clutter.Vertex[] verts) {
			clutter_actor_get_abs_allocation_vertices(Handle, verts);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_show_all(IntPtr raw);

		public void ShowAll() {
			clutter_actor_show_all(Handle);
		}

		[DllImport("clutter")]
		static extern byte clutter_actor_get_opacity(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_opacity(IntPtr raw, byte opacity);

		public byte Opacity { 
			get {
				byte raw_ret = clutter_actor_get_opacity(Handle);
				byte ret = raw_ret;
				return ret;
			}
			set {
				clutter_actor_set_opacity(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_rotation(IntPtr raw, int axis, double angle, int x, int y, int z);

		public void SetRotation(Clutter.RotateAxis axis, double angle, int x, int y, int z) {
			clutter_actor_set_rotation(Handle, (int) axis, angle, x, y, z);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_transformed_positionu(IntPtr raw, out int x, out int y);

		public void GetTransformedPositionu(out int x, out int y) {
			clutter_actor_get_transformed_positionu(Handle, out x, out y);
		}

		[DllImport("clutter")]
		static extern bool clutter_actor_is_scaled(IntPtr raw);

		public bool IsScaled { 
			get {
				bool raw_ret = clutter_actor_is_scaled(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_pick(IntPtr raw, IntPtr color);

		public void Pick(Clutter.Color color) {
			IntPtr native_color = GLib.Marshaller.StructureToPtrAlloc (color);
			clutter_actor_pick(Handle, native_color);
			color = Clutter.Color.New (native_color);
			Marshal.FreeHGlobal (native_color);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_position(IntPtr raw, out int x, out int y);

		public void GetPosition(out int x, out int y) {
			clutter_actor_get_position(Handle, out x, out y);
		}

		[DllImport("clutter")]
		static extern int clutter_actor_get_depthu(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_actor_set_depthu(IntPtr raw, int depth);

		public int Depthu { 
			get {
				int raw_ret = clutter_actor_get_depthu(Handle);
				int ret = raw_ret;
				return ret;
			}
			set {
				clutter_actor_set_depthu(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_clip(IntPtr raw, out int xoff, out int yoff, out int width, out int height);

		public void GetClip(out int xoff, out int yoff, out int width, out int height) {
			clutter_actor_get_clip(Handle, out xoff, out yoff, out width, out height);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_destroy(IntPtr raw);

		public void Destroy() {
			clutter_actor_destroy(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_scale(IntPtr raw, out double scale_x, out double scale_y);

		public void GetScale(out double scale_x, out double scale_y) {
			clutter_actor_get_scale(Handle, out scale_x, out scale_y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_raise_top(IntPtr raw);

		public void RaiseTop() {
			clutter_actor_raise_top(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_anchor_pointu(IntPtr raw, out int anchor_x, out int anchor_y);

		public void GetAnchorPointu(out int anchor_x, out int anchor_y) {
			clutter_actor_get_anchor_pointu(Handle, out anchor_x, out anchor_y);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_queue_redraw(IntPtr raw);

		public void QueueRedraw() {
			clutter_actor_queue_redraw(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_lower(IntPtr raw, IntPtr above);

		public void Lower(Clutter.Actor above) {
			clutter_actor_lower(Handle, above == null ? IntPtr.Zero : above.Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_sizeu(IntPtr raw, out int width, out int height);

		public void GetSizeu(out int width, out int height) {
			clutter_actor_get_sizeu(Handle, out width, out height);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_set_scalex(IntPtr raw, int scale_x, int scale_y);

		public void SetScalex(int scale_x, int scale_y) {
			clutter_actor_set_scalex(Handle, scale_x, scale_y);
		}

		[DllImport("clutter")]
		static extern uint clutter_actor_get_gid(IntPtr raw);

		public uint Gid { 
			get {
				uint raw_ret = clutter_actor_get_gid(Handle);
				uint ret = raw_ret;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_allocation_vertices(IntPtr raw, IntPtr ancestor, Clutter.Vertex[] verts);

		public void GetAllocationVertices(Clutter.Actor ancestor, Clutter.Vertex[] verts) {
			clutter_actor_get_allocation_vertices(Handle, ancestor == null ? IntPtr.Zero : ancestor.Handle, verts);
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_actor_get_stage(IntPtr raw);

		public Clutter.Actor Stage { 
			get {
				IntPtr raw_ret = clutter_actor_get_stage(Handle);
				Clutter.Actor ret = GLib.Object.GetObject(raw_ret) as Clutter.Actor;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern void clutter_actor_reparent(IntPtr raw, IntPtr new_parent);

		public void Reparent(Clutter.Actor new_parent) {
			clutter_actor_reparent(Handle, new_parent == null ? IntPtr.Zero : new_parent.Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_get_allocation_coords(IntPtr raw, out int x_1, out int y_1, out int x_2, out int y_2);

		public void GetAllocationCoords(out int x_1, out int y_1, out int x_2, out int y_2) {
			clutter_actor_get_allocation_coords(Handle, out x_1, out y_1, out x_2, out y_2);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_apply_transform_to_point(IntPtr raw, IntPtr point, IntPtr vertex);

		public void ApplyTransformToPoint(Clutter.Vertex point, Clutter.Vertex vertex) {
			IntPtr native_point = GLib.Marshaller.StructureToPtrAlloc (point);
			IntPtr native_vertex = GLib.Marshaller.StructureToPtrAlloc (vertex);
			clutter_actor_apply_transform_to_point(Handle, native_point, native_vertex);
			point = Clutter.Vertex.New (native_point);
			Marshal.FreeHGlobal (native_point);
			vertex = Clutter.Vertex.New (native_vertex);
			Marshal.FreeHGlobal (native_vertex);
		}

		[DllImport("clutter")]
		static extern void clutter_actor_lower_bottom(IntPtr raw);

		public void LowerBottom() {
			clutter_actor_lower_bottom(Handle);
		}

#endregion
	}
}
