// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Clutter {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public  class Model : GLib.Object {

		[Obsolete]
		protected Model(GLib.GType gtype) : base(gtype) {}
		public Model(IntPtr raw) : base(raw) {}

		protected Model() : base(IntPtr.Zero)
		{
			CreateNativeObject (new string [0], new GLib.Value [0]);
		}

		[GLib.CDeclCallback]
		delegate void SortChangedVMDelegate (IntPtr model);

		static SortChangedVMDelegate SortChangedVMCallback;

		static void sortchanged_cb (IntPtr model)
		{
			try {
				Model model_managed = GLib.Object.GetObject (model, false) as Model;
				model_managed.OnSortChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideSortChanged (GLib.GType gtype)
		{
			if (SortChangedVMCallback == null)
				SortChangedVMCallback = new SortChangedVMDelegate (sortchanged_cb);
			OverrideVirtualMethod (gtype, "sort-changed", SortChangedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Model), ConnectionMethod="OverrideSortChanged")]
		protected virtual void OnSortChanged ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("sort-changed")]
		public event System.EventHandler SortChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "sort-changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "sort-changed");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void FilterChangedVMDelegate (IntPtr model);

		static FilterChangedVMDelegate FilterChangedVMCallback;

		static void filterchanged_cb (IntPtr model)
		{
			try {
				Model model_managed = GLib.Object.GetObject (model, false) as Model;
				model_managed.OnFilterChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideFilterChanged (GLib.GType gtype)
		{
			if (FilterChangedVMCallback == null)
				FilterChangedVMCallback = new FilterChangedVMDelegate (filterchanged_cb);
			OverrideVirtualMethod (gtype, "filter-changed", FilterChangedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Model), ConnectionMethod="OverrideFilterChanged")]
		protected virtual void OnFilterChanged ()
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (1);
			GLib.Value[] vals = new GLib.Value [1];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("filter-changed")]
		public event System.EventHandler FilterChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "filter-changed");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "filter-changed");
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void RowChangedSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void RowChangedSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.RowChangedArgs args = new Clutter.RowChangedArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = GLib.Object.GetObject(arg1) as Clutter.ModelIter;
				Clutter.RowChangedHandler handler = (Clutter.RowChangedHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.CDeclCallback]
		delegate void RowChangedVMDelegate (IntPtr model, IntPtr iter);

		static RowChangedVMDelegate RowChangedVMCallback;

		static void rowchanged_cb (IntPtr model, IntPtr iter)
		{
			try {
				Model model_managed = GLib.Object.GetObject (model, false) as Model;
				model_managed.OnRowChanged (GLib.Object.GetObject(iter) as Clutter.ModelIter);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowChanged (GLib.GType gtype)
		{
			if (RowChangedVMCallback == null)
				RowChangedVMCallback = new RowChangedVMDelegate (rowchanged_cb);
			OverrideVirtualMethod (gtype, "row-changed", RowChangedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Model), ConnectionMethod="OverrideRowChanged")]
		protected virtual void OnRowChanged (Clutter.ModelIter iter)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (iter);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("row-changed")]
		public event Clutter.RowChangedHandler RowChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-changed", new RowChangedSignalDelegate(RowChangedSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-changed", new RowChangedSignalDelegate(RowChangedSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void RowRemovedSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void RowRemovedSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.RowRemovedArgs args = new Clutter.RowRemovedArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = GLib.Object.GetObject(arg1) as Clutter.ModelIter;
				Clutter.RowRemovedHandler handler = (Clutter.RowRemovedHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.CDeclCallback]
		delegate void RowRemovedVMDelegate (IntPtr model, IntPtr iter);

		static RowRemovedVMDelegate RowRemovedVMCallback;

		static void rowremoved_cb (IntPtr model, IntPtr iter)
		{
			try {
				Model model_managed = GLib.Object.GetObject (model, false) as Model;
				model_managed.OnRowRemoved (GLib.Object.GetObject(iter) as Clutter.ModelIter);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowRemoved (GLib.GType gtype)
		{
			if (RowRemovedVMCallback == null)
				RowRemovedVMCallback = new RowRemovedVMDelegate (rowremoved_cb);
			OverrideVirtualMethod (gtype, "row-removed", RowRemovedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Model), ConnectionMethod="OverrideRowRemoved")]
		protected virtual void OnRowRemoved (Clutter.ModelIter iter)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (iter);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("row-removed")]
		public event Clutter.RowRemovedHandler RowRemoved {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-removed", new RowRemovedSignalDelegate(RowRemovedSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-removed", new RowRemovedSignalDelegate(RowRemovedSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void RowAddedSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void RowAddedSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			Clutter.RowAddedArgs args = new Clutter.RowAddedArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = GLib.Object.GetObject(arg1) as Clutter.ModelIter;
				Clutter.RowAddedHandler handler = (Clutter.RowAddedHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.CDeclCallback]
		delegate void RowAddedVMDelegate (IntPtr model, IntPtr iter);

		static RowAddedVMDelegate RowAddedVMCallback;

		static void rowadded_cb (IntPtr model, IntPtr iter)
		{
			try {
				Model model_managed = GLib.Object.GetObject (model, false) as Model;
				model_managed.OnRowAdded (GLib.Object.GetObject(iter) as Clutter.ModelIter);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRowAdded (GLib.GType gtype)
		{
			if (RowAddedVMCallback == null)
				RowAddedVMCallback = new RowAddedVMDelegate (rowadded_cb);
			OverrideVirtualMethod (gtype, "row-added", RowAddedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(Clutter.Model), ConnectionMethod="OverrideRowAdded")]
		protected virtual void OnRowAdded (Clutter.ModelIter iter)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (iter);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("row-added")]
		public event Clutter.RowAddedHandler RowAdded {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-added", new RowAddedSignalDelegate(RowAddedSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "row-added", new RowAddedSignalDelegate(RowAddedSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("clutter")]
		static extern bool clutter_model_filter_row(IntPtr raw, uint row);

		public bool FilterRow(uint row) {
			bool raw_ret = clutter_model_filter_row(Handle, row);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_model_get_column_type(IntPtr raw, uint column);

		public GLib.GType GetColumnType(uint column) {
			IntPtr raw_ret = clutter_model_get_column_type(Handle, column);
			GLib.GType ret = new GLib.GType(raw_ret);
			return ret;
		}

		[DllImport("clutter")]
		static extern int clutter_model_get_sorting_column(IntPtr raw);

		[DllImport("clutter")]
		static extern void clutter_model_set_sorting_column(IntPtr raw, int column);

		public int SortingColumn { 
			get {
				int raw_ret = clutter_model_get_sorting_column(Handle);
				int ret = raw_ret;
				return ret;
			}
			set {
				clutter_model_set_sorting_column(Handle, value);
			}
		}

		[DllImport("clutter")]
		static extern uint clutter_model_get_n_rows(IntPtr raw);

		public uint NRows { 
			get {
				uint raw_ret = clutter_model_get_n_rows(Handle);
				uint ret = raw_ret;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_model_get_column_name(IntPtr raw, uint column);

		public string GetColumnName(uint column) {
			IntPtr raw_ret = clutter_model_get_column_name(Handle, column);
			string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
			return ret;
		}

		[DllImport("clutter")]
		static extern void clutter_model_set_types(IntPtr raw, uint n_columns, IntPtr types);

		public void SetTypes(uint n_columns, GLib.GType types) {
			clutter_model_set_types(Handle, n_columns, types.Val);
		}

		[DllImport("clutter")]
		static extern void clutter_model_prependv(IntPtr raw, uint n_columns, out uint columns, IntPtr values);

		public uint Prependv(uint n_columns, GLib.Value values) {
			uint columns;
			IntPtr native_values = GLib.Marshaller.StructureToPtrAlloc (values);
			clutter_model_prependv(Handle, n_columns, out columns, native_values);
			values = (GLib.Value) Marshal.PtrToStructure (native_values, typeof (GLib.Value));
			Marshal.FreeHGlobal (native_values);
			return columns;
		}

		[DllImport("clutter")]
		static extern void clutter_model_set_filter(IntPtr raw, ClutterSharp.ModelFilterFuncNative func, IntPtr user_data, GLib.DestroyNotify notify);

		public Clutter.ModelFilterFunc Filter { 
			set {
				ClutterSharp.ModelFilterFuncWrapper value_wrapper;
				IntPtr user_data;
				GLib.DestroyNotify notify;
				if (value == null) {
					value_wrapper = null;
					user_data = IntPtr.Zero;
					notify = null;
				} else {
					value_wrapper = new ClutterSharp.ModelFilterFuncWrapper (value);
					user_data = (IntPtr) GCHandle.Alloc (value_wrapper);
					notify = GLib.DestroyHelper.NotifyHandler;
				}
				clutter_model_set_filter(Handle, value_wrapper.NativeDelegate, user_data, notify);
			}
		}

		[DllImport("clutter")]
		static extern uint clutter_model_get_n_columns(IntPtr raw);

		public uint NColumns { 
			get {
				uint raw_ret = clutter_model_get_n_columns(Handle);
				uint ret = raw_ret;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern void clutter_model_remove(IntPtr raw, uint row);

		public void Remove(uint row) {
			clutter_model_remove(Handle, row);
		}

		[DllImport("clutter")]
		static extern void clutter_model_set_names(IntPtr raw, uint n_columns, IntPtr[] names);

		public string[] Names { 
			set {
				int cnt_value = value == null ? 0 : value.Length;
				IntPtr[] native_value = new IntPtr [cnt_value];
				for (int i = 0; i < cnt_value; i++)
					native_value [i] = GLib.Marshaller.StringToPtrGStrdup (value[i]);
				clutter_model_set_names(Handle, (uint) (value == null ? 0 : value.Length), native_value);
				for (int i = 0; i < native_value.Length; i++) {
					value [i] = GLib.Marshaller.Utf8PtrToString (native_value[i]);
					GLib.Marshaller.Free (native_value[i]);
				}
			}
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_model_get_iter_at_row(IntPtr raw, uint row);

		public Clutter.ModelIter GetIterAtRow(uint row) {
			IntPtr raw_ret = clutter_model_get_iter_at_row(Handle, row);
			Clutter.ModelIter ret = GLib.Object.GetObject(raw_ret) as Clutter.ModelIter;
			return ret;
		}

		[DllImport("clutter")]
		static extern void clutter_model_set_sort(IntPtr raw, uint column, ClutterSharp.ModelSortFuncNative func, IntPtr user_data, GLib.DestroyNotify notify);

		public void SetSort(uint column, Clutter.ModelSortFunc func) {
			ClutterSharp.ModelSortFuncWrapper func_wrapper;
			IntPtr user_data;
			GLib.DestroyNotify notify;
			if (func == null) {
				func_wrapper = null;
				user_data = IntPtr.Zero;
				notify = null;
			} else {
				func_wrapper = new ClutterSharp.ModelSortFuncWrapper (func);
				user_data = (IntPtr) GCHandle.Alloc (func_wrapper);
				notify = GLib.DestroyHelper.NotifyHandler;
			}
			clutter_model_set_sort(Handle, column, func_wrapper.NativeDelegate, user_data, notify);
		}

		[DllImport("clutter")]
		static extern void clutter_model_insert_value(IntPtr raw, uint row, uint column, IntPtr value);

		public void InsertValue(uint row, uint column, GLib.Value value) {
			IntPtr native_value = GLib.Marshaller.StructureToPtrAlloc (value);
			clutter_model_insert_value(Handle, row, column, native_value);
			value = (GLib.Value) Marshal.PtrToStructure (native_value, typeof (GLib.Value));
			Marshal.FreeHGlobal (native_value);
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_model_get_last_iter(IntPtr raw);

		public Clutter.ModelIter LastIter { 
			get {
				IntPtr raw_ret = clutter_model_get_last_iter(Handle);
				Clutter.ModelIter ret = GLib.Object.GetObject(raw_ret) as Clutter.ModelIter;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_model_get_first_iter(IntPtr raw);

		public Clutter.ModelIter FirstIter { 
			get {
				IntPtr raw_ret = clutter_model_get_first_iter(Handle);
				Clutter.ModelIter ret = GLib.Object.GetObject(raw_ret) as Clutter.ModelIter;
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern void clutter_model_resort(IntPtr raw);

		public void Resort() {
			clutter_model_resort(Handle);
		}

		[DllImport("clutter")]
		static extern void clutter_model_appendv(IntPtr raw, uint n_columns, out uint columns, IntPtr values);

		public uint Appendv(uint n_columns, GLib.Value values) {
			uint columns;
			IntPtr native_values = GLib.Marshaller.StructureToPtrAlloc (values);
			clutter_model_appendv(Handle, n_columns, out columns, native_values);
			values = (GLib.Value) Marshal.PtrToStructure (native_values, typeof (GLib.Value));
			Marshal.FreeHGlobal (native_values);
			return columns;
		}

		[DllImport("clutter")]
		static extern void clutter_model_foreach(IntPtr raw, ClutterSharp.ModelForeachFuncNative func, IntPtr user_data);

		public void Foreach(Clutter.ModelForeachFunc func) {
			ClutterSharp.ModelForeachFuncWrapper func_wrapper = new ClutterSharp.ModelForeachFuncWrapper (func);
			clutter_model_foreach(Handle, func_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("clutter")]
		static extern bool clutter_model_filter_iter(IntPtr raw, IntPtr iter);

		public bool FilterIter(Clutter.ModelIter iter) {
			bool raw_ret = clutter_model_filter_iter(Handle, iter == null ? IntPtr.Zero : iter.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("clutter")]
		static extern IntPtr clutter_model_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = clutter_model_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("clutter")]
		static extern void clutter_model_insertv(IntPtr raw, uint row, uint n_columns, out uint columns, IntPtr values);

		public uint Insertv(uint row, uint n_columns, GLib.Value values) {
			uint columns;
			IntPtr native_values = GLib.Marshaller.StructureToPtrAlloc (values);
			clutter_model_insertv(Handle, row, n_columns, out columns, native_values);
			values = (GLib.Value) Marshal.PtrToStructure (native_values, typeof (GLib.Value));
			Marshal.FreeHGlobal (native_values);
			return columns;
		}

#endregion
	}
}
